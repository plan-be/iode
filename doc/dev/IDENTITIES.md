<!-- This content was generated by scr4w_amd -->

# Table of Contents



- [IODE: execution of identities](#T1)
    - [Introduction](#T2)
    - [Order of execution](#T3)
      - [Example](#T4)
    - [VAR and Scalar source files](#T5)
    - [Execution sample](#T6)
    - [List of functions](#T7)

# IODE: execution of identities {#T1}

### Introduction {#T2}

IODE identities are simple LEC expressions. Each identity has a name which is the name of the variable that will be created or updated by the "execution" (i.e. calculation) of that identity.

### Order of execution {#T3}

The order of execution of a set of identities is computed by IODE in such a way that the "dependent" identities are calculated after their predecessors.

#### Example {#T4}

Suppose we have 3 identities to execute:

|Idt name|Formula|
|:---|:---|
|`A`|`B+C`|
|`B`|`C * 2 * alpha`|
|`E`|`X + Y`|

The order of execution is automatically calcuted => \[1, 0, 2\]. Indeed, B must be computed before A because A is a successor of B. E remains in 3d position.

### VAR and Scalar source files {#T5}

The variables and scalars needed to compute the identities are read either in the current WS or in a set of external files.

In the example above, the variables X, Y and C, and the scalar alpha, are needed to perform the calculation. If no information on external files are given, X, Y and C are searched in the current KV\_WS and, similarly, alpha in KS\_WS. If one of them cannot be found, the process stops with an error.

If these objects are not present in KV\_WS / KS\_WS, the user must thus provide one or more source files. Note the order in which these files are specified is important because as soon as an object is found, it is not searched in the following files.

To specify that an object must be searched in the current WS before the other files, the special name `WS` must be given.

Let's say that

- X and C are in the current WS,
- X and Y can be found in filexy.var
- alpha is in filealpha.scl.

If we provide as VAR source files `"WS filexy.var"`:

|**Name**|**Formula**|Source|
|:---|:---|:---|
|`A`|`B+C`|C:WS, B:calculated|
|`B`|`C * 2 * alpha`|C:WS|
|`E`|`X + Y`|**X:WS**, Y:filexy|

- **X** and C will be read in WS,
- Y will be read in filexy

On the other hand, if we provide as VAR source files `"filexy.var"` without `"WS"`, C cannot be found and the execution will stop.

Finally, if we provide as VAR source files `"filexy.var WS"`:

|**Name**|**Formula**|Source|
|:---|:---|:---|
|`A`|`B+C`|C:WS, B:calculated|
|`B`|`C * 2 * alpha`|C:WS|
|`E`|`X + Y`|**X:filexy** and Y: filexy|

- **X and Y** will be read in filexy.var
- C will be read in WS,

The same principle applies to scalar source files.

### Execution sample {#T6}

When VARs are read from external files, they are shortened or expanded to match the current WS sample.

On the other hand, one can execute identities on a sub\-sample. In this case, there are 2 possibilities:

- if a calculated VAR already exists in the current WS, its values are left unchanged outside the calculation sample
- if the VAR is created, the values outside the calculation sample are set to L\_NAN.

### List of functions {#T7}

|Syntax|Description|
|:---|:---|
|`KDB *KI_exec(KDB* dbi, KDB* dbv, int nv, char* vfiles[], KDB* dbs, int ns, char* sfiles[], Sample* smpl)`|Executes all identities in dbi using the input series of dbv and scalars of dbs. Missing vars and scalars are collected from vfiles and sfiles.|

