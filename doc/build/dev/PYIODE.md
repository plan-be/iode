<!-- This content was generated by scr4w_amd -->

# Table of Contents



- [IODE: the python module](#T1)
    - [Memory management](#T2)
      - [Interface IODE \- Python \- IODE](#T3)
      - [Source files (\*.pyx, \*.pxi and \*.c)](#T4)
    - [How to add a new Py\-function based on a C\-function](#T5)
      - [Step 1: in C](#T6)
      - [Step 2: In \{P\|C\}ython](#T7)
      - [Step 3: in a DOS command prompt](#T8)

# IODE: the python module {#T1}

### Memory management {#T2}

#### Interface IODE \- Python \- IODE {#T3}

During a PYIODE session, IODE data are grouped in workspaces, one by object type (variables, scalars, equations...) and stored in memory using a proprietary memory management system (IODE\-SWAP).

IODE functions operate **inside** IODE\-SWAP memory. Exchanges between IODE objects (in IODE\-SWAP) and python objects (larray, numpy or pandas objects in python memory) are made possible via interface functions like `get_eqs()`, `set_eqs()` or `larray_to_ws()`.

#### Source files (\*.pyx, \*.pxi and \*.c) {#T4}

The python functions are grouped, according to their specific topics, in the files `pyiode_*.pyx` where \* can be ws, sample, objects, larray, reports... Some utility functions have also been added in the `pyiode_util.pyx` source file.

The signatures of the C\-api functions used in the python sources can be found in `iode.pxi`. These functions are declared in iode.h (mostly in the sub file `iodeapi.h`) and defined (for the most part) in `b_api.c`.

### How to add a new Py\-function based on a C\-function {#T5}

#### Step 1: in C {#T6}

Create the new function in one of the iode_c_api C modules, for example in `api/b_api.c`:

```
   
         int IodeMyFn(char* name) {
            source code...
         }
```

Declare the new function in `api/iodeapi.h`

For the Visual Studio (CMake) version:

- regenerate `iode_c_api.lib` (using CMake)

For non Visual Studio version (standard Microsoft `nmake` / cl compiler):

- Goto `../api/vc64`
- Call `"C:\Program Files (x86)\Microsoft Visual Studio\2019ommunity\VC\Auxiliaryuild\vcvars64.bat"` to create the environment variables for VC64 nmake
- Execute `nmake` to create 64 bits `iode_c_api.lib`

For example:

```
    c:> cd /usr/iode_src/api/vc64
    c:/usr/iode_src/api/vc64> "C:\Program Files (x86)\Microsoft Visual Studio\2019ommunity\VC\Auxiliaryuild\vcvars64.bat"
    c:/usr/iode_src/api/vc64> nmake
```

#### Step 2: In \{P\|C\}ython {#T7}

Add the new function declaration in `iode.pxi` in the section `cdef extern from "iode.h"`:

```
    cdef int IodeMyFn(char* name)  
```

(Note that there is no semi\-colon at the end of the line \!)

Create the Python equivalent to `IodeMyFn()` in the appropriate module `pyiode_*.pyx`.

```
    def myfn(arg):
        return IodeMyFn(cstr(arg))
```

If needed, use the python utility functions:

- `cstr()` to translate python strings (utf8) to C char\* (ansi code cp850)
- `pystr()` to do the reverse
- `pylist(char** c_list)` to convert C char\*\* to python lists (don't forget to free c\_list afterwards, e.g. by a call to SCR\_free\_tbl(c\_list))
- `pyfloats(double *cvar, int lg)` to convert a vector of doubles of length lg into a python list of doubles

#### Step 3: in a DOS command prompt {#T8}

```
    c:\> cd  <path_to_iode>/pyiode
    c:<path_to_iode>/pyiode> set64
    c:<path_to_iode>/pyiode> activate 
    c:<path_to_iode>/pyiode> makepy
```

