from pathlib import Path
import xml.etree.ElementTree as ET


def generate_header(filepath, ui_class, class_name, slots):
    slots = "\n".join([f"\tvoid {slot};" for slot in slots])
    filename = filepath.stem
    with open(filepath, mode='w', encoding='utf-8') as f:
        f.write(
            f'''
#pragma once

#include <QObject>
#include <QDialog>
#include <QString>
#include <QSettings>
#include <QMap>
#include <QMessageBox>

#include <string>

#include "../../utils.h"
#include "../../bridge.h"
#include "../../wrapper_classes.h"
#include "ui_{filename}.h"


/* NOTE FOR THE DEVELOPERS:
 * All Menu Dialog classes MUST 
 * 1. inherit from MixinSettings,
 * 2. use the extractAndVerify() method to extract input data from fields,
 * 3. call the Q_OBJECT macro at the beginning of the class to allow slots and signals (see documentation of Qt),
 * 4. have a private pointer *ui to the associated class generated by the Qt Designer.
 */
 // TODO: implement the class below
class {class_name} : public MixinSettings
{{
    Q_OBJECT

private:
    Ui::{ui_class}* ui;

public:
    {class_name}(QSettings& settings, QWidget* parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());
    ~{class_name}();

public slots:
{slots}
}};
'''
        )


def generate_source(filepath, ui_class, class_name, slots):
    slots = "\n\n".join([f"void {class_name}::{slot}\n{{\n// TODO: implement this\n}}" for slot in slots])
    filename = filepath.stem
    with open(filepath, mode='w', encoding='utf-8') as f:
        f.write(
            f'''
#include "{filename}.h"


/* NOTE FOR THE DEVELOPERS:
 * The constructor of a Menu Dialog class deriving from MixingSettings MUST:
 * 1. instantiate the pointer *ui,
 * 2. call ui->setupUi(this),
 * 3. use the Wrapper classes defined in the wrapper_classes.h header file to wrap the input field items,
 * 4. fill the mapFields member (inherited from MixinSettings) with the wrapped field items,
 * 5. initialize the inherited className member (using typeid(this).name()) 
 * 6. call the loadSettings() method (inherited from MixinSettings).
 */
{class_name}::{class_name}(QSettings& settings, QWidget* parent, Qt::WindowFlags f) : MixinSettings(settings, parent, f)
{{
    ui = new Ui::{ui_class}();
    ui->setupUi(this);

    // TODO: use Wrapper classes (see wrapper_classes.h) to wrap input field items
    /* Examples:
     * input_type = new WrapperComboBox(ui->label_input_type->text(), *ui->comboBox_input_type, Required, qmapIodeTypes);
     * input_file = new WrapperFileChooser(ui->label_input_file->text(), *ui->fileChooser_input_file, Required, AnyFile, ExistingFile);
     * sample_from = new WrapperSampleEdit(ui->label_sample->text() + QString("From"), *ui->sampleEdit_sample_from, Required);
     */

    // TODO: fill mapFields
    /* Examples:
     * mapFields["InputType"] = input_type;
     * mapFields["InputFile"] = input_file;
     * mapFields["SampleFrom"] = sample_from;
     */

    // TODO: if possible, find a way to initialize className inside MixingSettings
    // NOTE FOR DEVELOPPERS: we cannot simply call the line below from the constructor of MixingSettings 
    //                       since in that case this refers to MixingSettings and NOT the derived class
    className = QString::fromStdString(typeid(this).name());
    loadSettings();
}}

{class_name}::~{class_name}()
{{
    delete ui;
}}

{slots}
'''
        )


def parse_ui_file(ui_file):
    tree = ET.parse(ui_file)
    root = tree.getroot()
    ui_class = root.find('class').text
    print(f'\tUI class name: {ui_class}')

    slots = []
    for connection in root.findall('./connections/connection'):
        slot = connection.find('slot').text
        if slot not in ["accept()", "reject()", "help()"]:
            slots += [slot]
    print('\tslots: [', ', '.join(slots), ']')

    return ui_class, slots


if __name__ == "__main__":
    prefix = ''
    except_ = ['file_import', 'file_export', 'workspace_load', 'workspace_save']

    current_dir = Path('.').absolute()
    for ui_file in current_dir.glob(f'**/{prefix}*.ui'): 
        print(f"processing {ui_file.stem}...")
        header_file = ui_file.with_suffix('.h')
        source_file = ui_file.with_suffix('.cpp')
        #if not header_file.exists():        
        if ui_file.stem not in except_:        
            ui_class, slots = parse_ui_file(ui_file)
            # from snake_case to CamelCase
            class_name = ''.join([x.title() for x in ui_class.split('_')]) + 'Dialog'
            print(f'\tC++ class name: {class_name}')
            generate_header(header_file, ui_class, class_name, slots)
            generate_source(source_file, ui_class, class_name, slots)
            print("done\n")
