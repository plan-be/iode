/**
 *  @header4iode
 * 
 *  Functions to import variables and comments from the legacy Bistel format (obsolete). 
 *  
 *  When loaded in 123, the format generated by the Belgostat program is as follows:
 *  
 *  BISTEL VAR format
 *  -----------------
 *     123456789012345     1       1980      1             456900     1       1
 *     (series nb)       (freq)    (year)    (per in year) (value)  (status)  (free)
 *     ........
 *
 *  List of functions 
 *  -----------------
 *  See k_idif.c for a similar group of functions.
 */
 
#include "iode.h"

extern  YYKEYS  IMP_DIF_KEYS[];

SAMPLE  BST_smpl;
char    BST_freq;
int     BST_nbper;

int IMP_hd_bst(yy, smpl)
YYFILE  *yy;
SAMPLE  *smpl;
{
    double  value;

    memcpy(&BST_smpl, smpl, sizeof(SAMPLE));
    BST_freq = (BST_smpl.s_p1).p_p;
    BST_nbper = PER_nbper(&(BST_smpl.s_p1));
    if(BST_nbper < 0) {
        kerror(0, "Please specify FROM and TO period");
        return(-1);
    }

    if(YY_lex(yy) != DIF_TABLE) return(-1);

    if(DIF_skip_to(yy, DIF_VECTORS) < 0) return(-1);
    if(DIF_cell(yy, NULL, &value) < 0) return(-1) ;

    if(DIF_skip_to(yy, DIF_TUPLES) < 0) return(-1);
    if(DIF_cell(yy, NULL, &value) < 0)  return(-1) ;

    if(DIF_skip_to(yy, DIF_BOT) < 0) return(-1);

    memcpy(&BST_smpl, smpl, sizeof(SAMPLE));
    return(0);
}


int IMP_elem_bst(yy, name, shift, vector)
YYFILE  *yy;
char    *name;
int     *shift;
IODE_REAL    *vector;
{
    char    buf[21], *str = NULL;
    long    y, s, nbper;
    double  value, status;
    PERIOD  *per;

    while(1) {
        if(DIF_cell(yy, &str, NULL) < 0) return(-1);
        SCR_strlcpy(name, str, 79); /* JMP 13-02-2013 */

        if(DIF_cell(yy, NULL, &value) < 0) return(-1);
        nbper = (long)floor(value);
        if(nbper != BST_nbper) {
            DIF_skip_to(yy, DIF_BOT);
            continue;
        }
        else break;
    }

    if(DIF_cell(yy, NULL, &value) < 0) return(-1);
    y = (long) floor(value);
    if(DIF_cell(yy, NULL, &value) < 0) return(-1);
    s = (long)floor(value);
    sprintf(buf, "%ld%c%ld", y, BST_freq, s);
    per = PER_atoper(buf);
    *shift = PER_diff_per(per, &(BST_smpl.s_p1));
    SW_nfree(per);

    if(DIF_cell(yy, NULL, &value) < 0) return(-1);
    if(DIF_cell(yy, NULL, &status) < 0) return(-1);
    if(status < 2) *vector = L_NAN;
    else *vector = value;

    DIF_skip_to(yy, DIF_BOT);
    return(0);
}

IMPDEF IMP_BST = {
    IMP_DIF_KEYS,
    8,
    IMP_hd_bst,
    NULL,
    IMP_elem_bst,
    NULL
};

/* Cmt */
YYFILE  *FYY, *RYY, *SYY;
KDB     *C_kdb = NULL;


YYFILE  *IMP_open_bst(keys, dim, name, suffix)
YYKEYS  *keys;
int     dim;
char    *name, *suffix;
{
    int     size;
    char    filename[K_MAX_FILE + 1];

    YY_CASE_SENSITIVE = 1;
    if(keys != NULL) size = dim;
    else size = 0;

    sprintf(filename, "%s%s", name, suffix);
    return(YY_open(filename, keys, size, YY_FILE));
}

char    *IMP_addftr(cmt, rubr, lang)
char    *cmt;
long    rubr;
int     lang;
{
    char    *fc = NULL, *nc = NULL, *ft;
    long    dummy, rub;

    while(1) {
        if(DIF_long(FYY, &dummy) < 0) break;  /* tbl */
        if(DIF_long(FYY, &dummy) < 0) break;  /* dom */
        if(DIF_long(FYY, &dummy) < 0) break;  /* as */

        if(DIF_long(FYY, &rub) < 0) break;

        if(DIF_cell(FYY, &fc, NULL) < 0) break;
        if(DIF_cell(FYY, &nc, NULL) < 0) break;
        DIF_skip_to(FYY, DIF_BOT);

        if(rubr == rub) break;
        SW_nfree(fc);
        SW_nfree(nc);
        fc = nc = NULL;
    }

    switch(lang) {
        case 0 :
            ft = NULL;
            break;
        case 1 :
            ft = fc;
            break;
        case 2 :
            ft = nc;
            break;
    }

    if(ft) {
        cmt = SW_nrealloc(cmt, strlen(cmt), strlen(cmt) + strlen(ft) + 5); /* JMP 07-04-98 */
        sprintf(cmt + strlen(cmt), " (%s) ", ft);
    }

    SW_nfree(fc);
    SW_nfree(nc);

    return(cmt);
}

IMP_hd_rbst(lang)
int     lang;
{
    char    *fc = NULL, *nc = NULL, *cmt = NULL; /* JMP 04-08-98 */
    long    dummy, rub, niv, ftr;
    char    name[80];
    int     lrub;

    if(DIF_skip_to(SYY, DIF_BOT) < 0) return(-1);
    if(DIF_skip_to(FYY, DIF_BOT) < 0) return(-1);
    if(DIF_skip_to(RYY, DIF_BOT) < 0) return(-1);

    C_kdb = K_create(K_CMT, K_ASIS);

    while(1) {
        if(DIF_long(RYY, &dummy) < 0) break;  /* tbl */
        if(DIF_long(RYY, &dummy) < 0) break;  /* dom */
        if(DIF_long(RYY, &dummy) < 0) break;  /* as */

        if(DIF_long(RYY, &rub) < 0) break;
        if(DIF_long(RYY, &niv) < 0) break;
        if(DIF_long(RYY, &ftr)  < 0) break;

        if(DIF_cell(RYY, &fc, NULL) < 0) break;
        if(DIF_cell(RYY, &nc, NULL) < 0) break;
        DIF_skip_to(RYY, DIF_BOT);

        lrub = (int)floor(log10((double) rub));
        switch(lrub) {
            case 0  :
                sprintf(name, "C000%ld_%ld", rub, niv);
                break;
            case 1  :
                sprintf(name, "C00%ld_%ld", rub, niv);
                break;
            case 2  :
                sprintf(name, "C0%ld_%ld", rub, niv);
                break;
            case 3  :
                sprintf(name, "C%ld_%ld", rub, niv);
                break;
            default :
                return(-1);
        }

        switch(lang) {
            case 0 :
                cmt = NULL;
                break;
            case 1 :
                cmt = SCR_stracpy(fc); /* JMP 04-08-98 */
                break;

            case 2 :
                cmt = SCR_stracpy(nc); /* JMP 04-08-98 */
                break;
        }

        if(ftr) cmt = IMP_addftr(cmt, rub, lang);

        if(cmt && K_add(C_kdb, name, cmt) < 0) return(-1);

        SW_nfree(fc);
        SW_nfree(nc);
        SW_nfree(cmt); /* JMP 04-08-98 */
    }

    YY_close(RYY);
    return(0);
}

IMP_hd_cbst(impdef, file, lang)
IMPDEF  *impdef;
char    *file;
int     lang;
{
    SCR_strip(file);
    FYY = IMP_open_bst(impdef->imp_keys, impdef->imp_dim, file, "ftr.dif");
    RYY = IMP_open_bst(impdef->imp_keys, impdef->imp_dim, file, "rub.dif");
    SYY = IMP_open_bst(impdef->imp_keys, impdef->imp_dim, file, "ser.dif");

    if(FYY == 0 || RYY == 0 || SYY == 0) {
        kerror(0,"Cannot open '%s'", file);
        return(-1);
    }

    if(IMP_hd_rbst(lang) < 0) {
        IMP_end_cbst();
        return(-1);
    }

    return(0);
}

DIF_long(yy, l_val)
YYFILE  *yy;
long    *l_val;
{
    double  d_val;

    if(DIF_cell(yy, NULL, &d_val) < 0) return(-1);

    *l_val = (long)floor(d_val);
    return(0);
}


IMP_vec_cbst(name, cmt)
char    *name;
char    **cmt;
{
    char    *str = NULL, *p_cmt[10];
    int     i, niv, r_niv, shift;
    long    dom, tbl, as1, as2;

    for(i = 0; i < 10; i++) {
        p_cmt[i] = NULL;
    }

    name[0] = '0';
    while(name[0] == '0') {
        if(DIF_long(SYY, &dom) < 0) return(-1);
        if(DIF_long(SYY, &tbl) < 0) return(-1);
        if(DIF_long(SYY, &as1) < 0) return(-1);
        if(DIF_long(SYY, &as2) < 0) return(-1);

        if(DIF_cell(SYY, &str, NULL) < 0) return(-1);
        strcpy(name, str);
        SW_nfree(str);
        DIF_skip_to(SYY, DIF_BOT);
    }

    as1 --;

    niv = IMP_niv(KONAME(C_kdb, as1));
    if(niv < 1 || niv > 9) return(-1);

    shift = niv;
    while(niv > 0 && as1 >= 0) {
        r_niv = IMP_niv(KONAME(C_kdb, as1));
        if(niv == r_niv) {
            str = KOVAL(C_kdb, as1);
            SCR_strfacpy(p_cmt + niv - 1, str);

            niv --;
        }

        as1 --;
    }

    if(as2 > 0) {
        niv = IMP_niv(KONAME(C_kdb, as2));
        while(niv > 0 && as2 >= 0 && niv + shift < 10) {
            r_niv = IMP_niv(KONAME(C_kdb, as2));
            if(niv == r_niv) {
                str = KOVAL(C_kdb, as2);
                SCR_strfacpy(p_cmt + niv + shift - 1, str);
                niv --;
            }

            as2 --;
        }
    }

    *cmt = SCR_mtov(p_cmt, ' ');

    for(i = 0; i < 10 && p_cmt[i]; i++) {
        SCR_free(p_cmt[i]);
        p_cmt[i] = NULL;
    }

    return(0);
}

int IMP_niv(name)
char    *name;
{
    int     pos, niv;
    ONAME   oname;
    char    *str;

    strcpy(oname, name);
    pos = U_pos('_', oname);
    str = oname + pos + 1;
    niv = atoi(str);

    return(niv);
}

IMP_end_cbst()
{
    K_free(C_kdb);
    YY_close(SYY);
    YY_close(FYY);
    return(0);
}




IMPDEF IMP_BST_CMT = {
    IMP_DIF_KEYS,
    8,
    IMP_hd_cbst,
    IMP_vec_cbst,
    NULL,
    IMP_end_cbst
};








