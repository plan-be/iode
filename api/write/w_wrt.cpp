/**
 *  @header4iode
 *
 *  Functions to generate IODE output on printer or in files.
 *   
 *  All outputs generated by IODE are based on the A2M engine of SCR4. 
 *  The only role of IODE is to generate A2M code to describes tables, graphs, equations, etc, in A2M language. 
 *  When this A2M code is complete, the final output is generated by the A2M engine of SCR4 for the selected destination.
 *  
 *  Available output destinations
 *  -----------------------------
 *  
 *  - W_A2M = A2M file 
 *  - W_MIF = mif  file (Adobe FrameMaker ascii format)
 *  - W_HTML = html  file
 *  - W_RTF = rtf  file
 *  - W_CSV = csv file
 *  - W_GDI = Windows printer
 *  
 *  Some outputs have limitations:
 *  
 *  - rtf files do not include graphs (an EMF/WMF version exists but is currenlty disabled. See SCR4)
 *  - csv files do not includes graphs 
 *  - html files use a commercial javascript library (Fusion Chart). A link to that lib is therefore required.
 *  
 *  The special output destination "W_DISP" is only used for graphs displayed on screen. It uses the TeeChart C++ library (Embarcadero).
 *   
 *  
 *  Usage
 *  -----
 *      1. initialise the output for a specific destination: 
 *          - W_dest(filename, type) 
 *  
 *      2. send commands and text in A2m language
 *          - W_print_tit(level);
 *          - W_printf(fmt, parms);
 *          - ...
 *          - W_flush() // Optional. Use when an object is complete (in memory)
 *  
 *      3. close the file or send to the printer
 *          - W_close()
 *  
 *      4. optionaly goto step 1 to create a new file / printout  
 *      
 *  Example
 *  -------
 *      W_dest("", W_GDI);              // Prepares to send output to the default printer (W_GDI)
 *      W_print_tit(1);
 *      W_printf((char*) "Title 1\n\n"); 
 *      ...
 *      W_close();                      // Flushes the memory buffer and sends the output to the printer
 *  
 *      W_dest("test1.htm", W_HTML);    // Creates test.html in HTML format (W_HTML)
 *      W_printf((char*) ".par1 tit_1\n");      // Save a2m code in memory
 *      W_printf((char*) "Title 1\n\n");        // id.
 *      ...
 *      W_close();                      // Flushes the memory buffer and saves the file test1.htm
 *  
 *  
 *  List of functions
 *  -----------------
 *   int W_dest(char *filename, int type)                                   Select a new printing destination in one of the available possible types
 *   int W_close()                                                          Ends a printing session by sending the objects in A2m memory to the printer or the output file.
 *   int W_flush()                                                          Sends the objects currently recorded in memory by A2mMemRecord() to the printer or the file.
 *   int W_printfEx(int dup, int ch1, int ch2, char* fmt, va_list args)     Records a text in A2m memory for printing after parsing the fmt argument.
 *   int W_printf(char* fmt, ...)                                           Records a text in A2m memory for printing.
 *   int W_printfDbl(char* fmt, ...)                                        Records a text in A2m memory for printing after parsing the fmt argument. Doubles the backslashes.
 *   int W_printfRepl(char* fmt, ...)                                       Records a text in A2m memory for printing after parsing the fmt argument. Replaces '&' by A2M_SEPCH.
 *   int W_printfReplEsc(char* fmt, ...)                                    Records a text in A2m memory for printing after parsing the fmt argument. Replaces '~' by A2M_ESCCH.
 *   int W_putc(int ch)                                                     Records a single character in A2m memory by a call to W_printf().
 *   int W_record(char *str)                                                Records a text in A2m memory.
 *   int W_InitDisplay()                                                    Defines the new output type as W_DISP (displays or creates a TeeChart graph file).
 *   int W_EndDisplay(char *title, int x, int y, int w, int h)              Closes the current printing session by sending the graphs to the screen.
 *   static int W_SavePrinterSettings()                                     Saves the current default printer and some of its settings.
 *   static int W_ResetPrinterSettings()                                    Restores the default printer and some of its settings.
 *   static int W_SetPrinterSettings()                                      Sets the default printer (defined by global W_gdiprinter) and some of its settings.
 *  
 *  List of global variables
 *  ------------------------
 *  
 *      char    W_filename[K_MAX_FILE + 1] = "";        Output file name
 *      int     W_type = 0;                             Current A2M output destination:
 *                                                      
 *      int     W_gdiask = 0;                           Ask the user which printer to send the data to. If null, selects the default printer.
 *      int     W_gdiorient = 0;                        Unused -- Printer page orientation: 0 = Portrait, 1 = Landscape
 *      int     W_gdiduplex = 0;                        Unused -- Printer duplex:
 *                                                           0 for simplex
 *                                                           1 for duplex
 *                                                           2 for vertical duplex
 *      char    W_gdiprinter[80] = "";                  Printer name
 *      int     W_a2mapp = 0;                           A2M Dest only:
 *                                                           0 => output file is reset,
 *                                                           1 => output is appended to the file
 *      int     W_rtfhelp = 0;                          RTF only: generate RTF output for the outdated Windows help format (.hlp).
 *      int     W_htmlhelp = 0;                         RTF only: generate HTML output for the Windows HEML help format (.chm).
 *  
 */

#include "write.h"
#include "api/b_a2mini.h"

// ====================================================================================================
// Function prototypes
// ----------------------------------------------------------------------------------------------------

static int W_InitParms();
static int W_open();
static int W_isempty(char *buf);
static int W_SavePrinterSettings();
static int W_ResetPrinterSettings();
static int W_SetPrinterSettings();


// ====================================================================================================
// Variable definitions 
// ----------------------------------------------------------------------------------------------------

static int      W_cont = 0;                     // Indicates that a printing session is active
static int      W_cancel = 0;                   // Indicates that the current printing session is cancelled (cannot open the output file for ex.) until the next call to W_open().
static A2MFILE* W_af;                           // Current A2M memory stream

// ====================================================================================================
// FUNCTIONS
// ----------------------------------------------------------------------------------------------------

/**
 *  Select a new printing destination in one of the available possible types:
 *      - W_GDI   synonym of A2M_DESTGDIPRT  => printer
 *      - W_A2M   synonym of A2M_DESTA2M     => a2m file
 *      - W_MIF   synonym of A2M_DESTFRM     => mif file
 *      - W_HTML  synonym of A2M_DESTHTML    => html file
 *      - W_RTF   synonym of A2M_DESTRTF     => rtf file
 *      - W_CSV   synonym of A2M_DESTCSV     => csv file
 *      - W_DUMMY synonym of A2M_DESTDUMMY   => no output
 *      - W_DISP  synonym of A2M_DESTTCHRT   => screen (graphs)
 *  
 *  If a printing session is currently open, that session is first closed 
 *  by calling W_close().
 *
 *  The filename is put in lowercase and an extension is added if not present.
 *
 *  @param [in] char*   filename    output filename
 *  @param [in] int     type        output type
 *  @return     int                 0
 */

int W_dest(char *filename, int type)
{
    char ext[4];

    ext[0] = 0;
    W_close();
    if(type > 1) 
    {
        switch(type) 
        {
        case A2M_DESTA2M :
            strcpy(ext, "a2m");
            break;
        case A2M_DESTFRM :
            strcpy(ext, "mif");
            break;
        case A2M_DESTHTML:
            strcpy(ext, "htm");
            break;
        case A2M_DESTRTF :
            strcpy(ext, "rtf");
            break;
        case A2M_DESTCSV :
            strcpy(ext, "csv");
            break;
#ifndef NOEMF
        case A2M_DESTGDIEMF :
            strcpy(ext, "emf");
            break;
        case A2M_DESTGDIWMF :
            strcpy(ext, "wmf");
            break;
#endif
        }

        SCR_strlcpy((unsigned char*) W_filename, (unsigned char*) filename, K_MAX_FILE);
        SCR_strip((unsigned char*)W_filename);
        SCR_lower((unsigned char*)W_filename);

        if(!U_is_in('.', W_filename)) 
            SCR_change_ext(W_filename, W_filename, ext);
    }
    else 
        W_filename[0] = 0;

    W_type = type;
    W_InitParms();
    return(0);
}


/**
 *  Reads in iode.ini the parameters for the current destination (defined in W_type) and
 *  sets some global variables accordingly.
 *
 *  @return int   0   always
 *
 */

static int W_InitParms()
{
    B_A2mGetGnlParms();
    switch(W_type) 
    {
    case W_GDI  :
        B_A2mGetGdiParms();
        break;
    case W_A2M  :
        B_A2mGetGnlParms();
        break;
    case W_RTF  :
        B_A2mGetRtfParms();
        SCR_free(A2M_PGHEAD);
        SCR_free(A2M_PGFOOT);
        A2M_MAXPARLEVEL = 3;
        A2M_PGHEAD = A2M_PGFOOT = 0;
        break;
    case W_HTML :
        B_A2mGetHtmlParms();
        B_A2mGetGIFParms();
        break;
    case W_MIF  :
        B_A2mGetMifParms();
        break;
    case W_CSV  :
        B_A2mGetCsvParms();
        break;
#ifndef __GNUC__
    case W_DISP :
        B_A2mGetGdiParms();
        if(WscrGetOSVersion(0L) == 2) 
        {
            A2M_GWIDTH = 7.5;
            A2M_GHEIGHT = 5.0;
        }
        else 
        {
            A2M_GWIDTH = 12.05;
            A2M_GHEIGHT = 8.35;
        }
        SCR_free(A2M_PGHEAD);
        SCR_free(A2M_PGFOOT);
        A2M_PGHEAD = A2M_PGFOOT = 0;
        break;
#endif
    default :
        break;
    }

    return(0);
}


/**
 *  If a printing session is currently open, does nothing. If not, starts a new printing session by calling
 *  A2mMemBegin().
 *
 *  If W_type is W_GDI (== A2M_DESTGDIPRT) the printer settings are saved in global vars and set according to the
 *  global variables read in W_InitParms(). The printer settings are reset by W_close().
 *
 *
 *  @return     int     0 on success or if a printing session in ongoing
 *                      1 on error (undefined filename for non printer output, illegal W_type)
 *                      -1 if W_filename cannot be opened.
 *
 */

static int W_open()
{
    int ask;

    if(W_af) 
        return(0);
    
    if(W_filename[0] == 0 && W_type > 1 && W_type < W_DISP) 
        return(1);

    switch(W_type) 
    {
    case A2M_DESTGDIPRT :
        ask = W_gdiask;
        break;
    case A2M_DESTA2M    :
        ask = W_a2mapp;
        break;
    case A2M_DESTRTF    :
        ask = W_rtfhelp;
        break;
    case A2M_DESTHTML   :
        ask = W_htmlhelp;
        break;
    default :
        ask = 0;
        break;
    }

    if(W_type == W_GDI) 
    {
        W_SavePrinterSettings();
        W_SetPrinterSettings();
    }

    W_af = A2mMemBegin(W_type, (unsigned char*) W_filename, ask);  /* JMP 06-02-98 */
    if(W_af == NULL) 
    {
        if(W_type == W_GDI) 
            W_ResetPrinterSettings();
        W_cancel = 1;
        return(-1);
    }

    return(0);
}


/**
 *  Ends a printing session by sending the objects in A2m memory to the printer or the output file.
 *
 *  Resets the printer settings if W_type is W_GDI. *
 *
 *  @return     int     0   always
 */

int W_close()
{
    if(W_af && W_cont) 
    {
        A2mMemEnd(W_af);
        W_af = 0;
        W_cont = 0;
    }
    
    W_cancel = 0;
    if(W_type == W_GDI) 
        W_ResetPrinterSettings();
    
    return(0);
}


/**
 *  Sends the objects currently recorded in memory by A2mMemRecord() to the printer or the file.
 *  If there is no current printing session, does nothing.
 *
 *  @return     int     -1 if there is no printing session
 *                      0 if a session is ongoing
 */

int W_flush()
{
    if(W_af == 0) 
        return(-1);
    
    A2mMemFlush(W_af);
    return(0);
}


/**
 *  Records a text in A2m memory for printing after parsing the fmt argument.
 *  Opens a new printing session if none is ongoing.
 *
 *  @param [in] int     dup     if not null, the backslashes (\) are doubled in the output
 *  @param [in] int     ch1     character to be replaced
 *  @param [in] int     ch2     replacement character
 *  @param [in] char*   fmt     argument (a la printf)
 *  @param [in] va_list args    list of parameters needed by fmt
 *  @return     int             0 on success
 *                              -1 if W_open() fails
 */

int W_printfEx(int dup, int ch1, int ch2, char* fmt, va_list args)
{
    char    buf[12400], str1[5], str2[5];
    int     rc = 0;

    if(W_cancel) 
        goto fin;
    
#ifdef _MSC_VER
    vsnprintf_s(buf, sizeof(buf) - 1, _TRUNCATE, fmt, args);
#else
    vsnprintf_s(buf, sizeof(buf) - 1, fmt, args);
#endif

    if(W_cont == 0 && W_isempty(buf)) 
        goto fin;
    
    if(W_open()) 
    {
        rc = -1;
        goto fin;
    }

    W_cont = 1;
    if(dup) 
        SCR_replace((unsigned char*) buf, (unsigned char*) "\\", (unsigned char*) "\\\\"); // TODO: check buf size !!!
    
    if(ch1 && ch2) 
    {
       str1[0] = ch1;
       str2[0] = ch2;
       str1[1] = str2[1] = 0;
       SCR_replace((unsigned char*) buf, (unsigned char*) str1, (unsigned char*) str2);
    }   
    
    A2mMemRecord(W_af, (unsigned char*) buf);

fin:
    return(rc);
}


/**
 *  Records a text in A2m memory for printing.
 *  See W_printfEx().
 *
 *  @param [in] char*   fmt     argument (a la printf)
 *  @param [in] va_list args    list of parameters needed by fmt
 *  @return     int             0 on success
 *                              -1 if W_open() fails
 */
int W_printf(char* fmt, ...)
{
    va_list myargs;
    int rc;

    va_start(myargs, fmt);
    rc = W_printfEx(0, 0, 0, fmt, myargs);
    va_end(myargs);

    return(rc);
}

/**
 *  Records a text in A2m memory for printing. Double the backslashes (for Windows filenames).
 *  See W_printfEx().
 *
 *  @param [in] char*   fmt     argument (a la printf)
 *  @param [in] va_list args    list of parameters needed by fmt
 *  @return     int             0 on success
 *                              -1 if W_open() fails
 */
int W_printfDbl(char* fmt, ...)
{
    va_list myargs;
    int rc;

    va_start(myargs, fmt);
    rc = W_printfEx(1, 0, 0, fmt, myargs);
    va_end(myargs);

    return(rc);
}

/**
 *  Records a text in A2m memory for printing. Replaces the char '&' by A2M_SEPCH.
 *  See W_printfEx().
 *
 *  @param [in] char*   fmt     argument (a la printf)
 *  @param [in] va_list args    list of parameters needed by fmt
 *  @return     int             0 on success
 *                              -1 if W_open() fails
 */
int W_printfRepl(char* fmt, ...)
{
    va_list myargs;
    int rc;

    va_start(myargs, fmt);
    rc = W_printfEx(0, '&', A2M_SEPCH, fmt, myargs);
    va_end(myargs);

    return(rc);
}

/**
 *  Records a text in A2m memory for printing. Replaces the char '~' by A2M_ESCCH (default \\).
 *  See W_printfEx().
 *
 *  @param [in] char*   fmt     argument (a la printf)
 *  @param [in] va_list args    list of parameters needed by fmt
 *  @return     int             0 on success
 *                              -1 if W_open() fails
 */
int W_printfReplEsc(char* fmt, ...)
{
    va_list myargs;
    int rc;

    va_start(myargs, fmt);
    rc = W_printfEx(0, '~', A2M_ESCCH, fmt, myargs);
    va_end(myargs);

    return(rc);
}




/**
 *  Records a single character in A2m memory by a call to W_printf().
 *
 *  @param [in] ch  char    Ascii character (OEM)
 *  @return     int         returned value of W_printf()
 */
int W_putc(int ch)
{
    return(W_printf((char*) "%c", ch));
}


/**
 *  Checks if a string contains characters other than " \t\n\r".
 *
 *  @param [in] char*   buf     buffer to analyse
 *  @return     int             0 if the buffer is not empty, 1 if it is empty.
 */
static int W_isempty(char* buf)
{
    int i;

    for(i = 0; buf[i]; i++) 
        if(!U_is_in(buf[i], " \t\n\r")) 
            return(0);

    return(1);
}


/**
 *  Records a text in A2m memory.
 *  Opens a new printing session if none is ongoing.
 *
 *  @param [in] char*  str  string to record
 *  @return     int         0 on success, -1 if the printing session cannot be opened.
 */
int W_record(char *str)
{
    if(W_cancel) 
        return(0);
    
    if(W_cont == 0 && W_isempty(str)) 
        return(0);
    
    if(W_open()) 
        return(-1);

    W_cont = 1;
    A2mMemRecord(W_af, (unsigned char*) str);
    return(0);
}


// ====================================================================================================
// Functions for displaying graphs in a window. 
// In older versions of IODE, the graphs were generated as EMF or WMF files.
// The latest versions use TeeChart as chart generator instead. 
// ----------------------------------------------------------------------------------------------------
 
#ifndef UNIX
#ifdef SCRW32
extern "C"  HWND    hMainWnd; /* JMP 01-02-98 */
#else
extern "C"  HWND    hWndDOS;
#endif
#endif

static long    W_emfnb = 0;     // EMF file number: iode<nnn>.emf or wmf

/**
 *  Defines the new output type as W_DISP (displays or creates a TeeChart graph file).
 *  Starts by ending the current printing session if one is in progress (in W_dest()).
 *  
 *  OBSOLETE : for EMF/WMF files, defines the new output filename based on W_emfnb.
 *  
 *  @global int     W_emfnb     EMF file number: iode<nnn>.emf or wmf
 *  @return int     0           always
 *  
 *  @note EMF and WMF have been replaced by TeeChart graphs
 */
int W_InitDisplay()
{
    char    tpath[K_MAX_FILE + 1], buf[K_MAX_FILE + 1];

    tpath[0] = 0; // !!!!!!!!!
    sprintf(buf, "%siode%ld", tpath, W_emfnb);
    W_dest(buf, W_DISP);
    return(0);
}


/**
 *  Closes the current printing session by sending the graphs to the screen.
 *  
 *  OBSOLETE : The generated charts are saved according to the current output type:
 *      A2M_DESTGDIEMF: saves in iode<nnn>.emf 
 *      A2M_DESTGDIWMF: saves in iode<nnn>.wmf
 *  W_emfnb is incremented.
 *  
 *  TODO: elaborate for EMF, WMF and TeeChart
 *
 *  @param [in] char*   title   title of the graph
 *  @param [in] int     x       x-position of the graph in the window
 *  @param [in] int     y       y-position of the graph in the window
 *  @param [in] int     w       width of the graph 
 *  @param [in] int     h       height of the graph 
 *  @return     int     0       always
 *  
 *  @global int     W_emfnb     EMF file number: iode<nnn>.emf or wmf
 */
int W_EndDisplay(char *title, int x, int y, int w, int h)
{
    char    tpath[K_MAX_FILE + 1], buf[K_MAX_FILE + 1];
    int     wmf = (W_type == A2M_DESTGDIWMF) ? 1 : 0;

    W_close();
    if(W_type == A2M_DESTTCHRT) 
        return(0); // TeeChart 
    
    // if(W_GetTempPath(80, tpath) == 0) tpath[0] = 0;
    // Normally never reached because W_DISP 
    tpath[0] = 0; // TODO:Check temp path
    if(W_type == A2M_DESTGDIEMF) 
        sprintf(buf, "%siode%ld.emf", tpath, W_emfnb);
    else                         
        sprintf(buf, "%siode%ld.wmf", tpath, W_emfnb);
    W_emfnb++;
#if !defined(UNIX) && !defined(NOEMF)
#ifdef SCRW32
    WscrEMFWMFCreateGnl(wmf, hMainWnd, buf, 0L, 1, x, y, w, h, title);  /* JMP 20-03-98 */
#else
//    WscrEMFPrint(hWndDOS, buf, 0L, 1);
    WscrEMFWMFCreateGnl(wmf, hWndDOS, buf, 0L, 1, x, y, w, h, title);      /* JMP 20-03-98 */
#endif
#endif // UNIX
    return(0);
}


// ====================================================================================================
// Functions to read, set and reset Printer settings
// ----------------------------------------------------------------------------------------------------

static char W_DftPrinterName[80];              // Default printer name
// int  W_DftPrinterOrient;
// int  W_DftPrinterDuplex;


/**
 *  Saves the current default printer and some of its settings.
 *  
 *  @note since 2016, some settings cannot be changed and have been disabled (duplex...)
 *  
 *  @global [out]   char*   W_DftPrinterName    default printer name
 *  @return         int     0   always
 */
 
static int W_SavePrinterSettings()
{
#ifndef __GNUC__
    if(WscrGetDefaultPrinter(W_DftPrinterName) < 0) 
        W_DftPrinterName[0] = 0;

    // W_DftPrinterOrient = WscrGetPrinterOrientation(W_DftPrinterName);
    // W_DftPrinterDuplex = WscrGetPrinterDuplex(W_DftPrinterName);
    return(0);
#else
    return(-1);
#endif
}

/**
 *  Restores the default printer and some of its settings.
 *  
 *  @global [in]    char*   W_DftPrinterName    default printer name
 *  @return         int     0 on succes, 
 *                          -1 if the current default printer cannot be determined
 */
 
static int W_ResetPrinterSettings()
{
#ifndef __GNUC__
    char    buf[80];

    if(WscrGetDefaultPrinter(buf) < 0) 
        return(-1);

    if(W_DftPrinterName[0] == 0) 
        return(0);
    
    if(strcmp(W_DftPrinterName, buf))
        WscrSetDefaultPrinter(W_DftPrinterName);

    // WscrSetPrinterOrientation(buf, W_DftPrinterOrient); // JMP 22/8/2016
    // WscrSetPrinterDuplex(buf, W_DftPrinterDuplex); // JMP 22/8/2016
    return(0);
#else
    return(-1);
#endif
}

/**
 *  Sets the default printer (defined by global W_gdiprinter) and some of its settings.
 *  
 *  @note since 2016, some settings cannot be changed and have been disabled (duplex...)
 *  
 *  @global [in]    char*   W_gdiprinter    new default printer name
 *  @return         int     0 on succes, 
 *                          -1 if the current default printer cannot be determined
 */
 
static int W_SetPrinterSettings()
{
#ifndef __GNUC__
    char    buf[80];

    if(W_gdiprinter[0]) 
        WscrSetDefaultPrinter(W_gdiprinter);

    if(WscrGetDefaultPrinter(buf) < 0) 
        return(-1);
    
    // WscrSetPrinterOrientation(buf, W_gdiorient); 
    // WscrSetPrinterDuplex(buf, W_gdiduplex);
    return(0);
#else
    return(-1);
#endif
}
