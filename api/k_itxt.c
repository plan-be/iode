/**
 *  @header4iode
 * 
 *  Functions to import variables and comments from the legacy Belgostat format (obsolete). 
 *  
 *  Format
 *  ------
 *      N;0104104000023;   1;19801231;               8,3;D
 *      D;code;freq;date;value;status
 *   
 *      0104104000023;N;Werkloosheidsgraden (bron: Eurostat), Seizoengezuiverde gegevens;Taux de chômage (source: Eurostat), Données désaissonnalisées;Taux de chômage (source: Eurostat), Données désaissonnalisées;           ;             0,010;
 *      code;N;cmtnl;cmtfr;cmten;units1;units2
 *
 *  List of functions 
 *  -----------------
 *  See k_idif.c for a similar group of functions.
 */

#include "iode.h"

/*
    Reads a txt file with the following description when loaded in excel
    this is the format generated by the Belgostat program

*/
FILE    *TXT_fd;
SAMPLE  TXT_smpl;
char    TXT_freq;
int     TXT_nbper;
int     TXT_lang;

int IMP_hd_txt(yy, smpl)
YYFILE  *yy;
SAMPLE  *smpl;
{
    memcpy(&TXT_smpl, smpl, sizeof(SAMPLE));
    TXT_freq = (TXT_smpl.s_p1).p_p;
    TXT_nbper = PER_nbper(&(TXT_smpl.s_p1));
    if(TXT_nbper < 0) {
        kerror(0, "Please specify FROM and TO period");
        return(-1);
    }

    TXT_fd = yy->yy_fd;
    return(0);
}

int TXT_set(date, shift, tval, dval)
char    *date, *tval;
int     *shift;
IODE_REAL    *dval;
{
    PERIOD  *per;
    char    buf[21], y[5], m[3];
    int     pos;
    long    ly, lm;

    SCR_strlcpy(y, date, 4);
    y[4] = 0;
    ly = atoi(y);        /* JMP 13-02-2013 */
    SCR_strlcpy(m, date + 4, 2);
    m[2] = 0;
    lm = atoi(m);    /* JMP 13-02-2013 */

    switch(TXT_freq) {
        case 'Q' :
            lm = 1 + lm/4;
            break; /* JMP 05-10-00 */
        case 'Y' :
            lm = lm/12;
            break;
    }

    sprintf(buf, "%ld%c%ld", ly, TXT_freq, lm);
    per = PER_atoper(buf);
    *shift = PER_diff_per(per, &(TXT_smpl.s_p1));
    SW_nfree(per);

    pos = U_pos(',', tval);
    if(pos>=0) tval[pos] = '.';

    *dval= atof(tval);
    
    return(0);
}

int IMP_elem_txt(yy, name, shift, vector)
YYFILE  *yy;
char    *name;
int     *shift;
IODE_REAL    *vector;
{
    char    buf[257], **tbl = NULL;
    long    nbper;

    while(1) {
        if(fgets(buf, 256, TXT_fd) == NULL)  return(-1);
        tbl = SCR_vtoms(buf, "; ");
        if(SCR_tbl_size(tbl) != 6) {
            SCR_free_tbl(tbl);
            continue;
        }
        /* The same periodicity */
        nbper = atoi(tbl[2]);
        if(nbper != TXT_nbper) {
            SCR_free_tbl(tbl);
            continue;
        }
        else break;
    }

    SCR_strlcpy(name, tbl[1], 79); /* JMP 13-02-2013 */
    TXT_set(tbl[3], shift, tbl[4], vector);
    SCR_free_tbl(tbl);
    return(0);
}


IMPDEF IMP_TXT = {
    NULL,
    0,
    IMP_hd_txt,
    NULL,
    IMP_elem_txt,
    NULL
};



IMP_hd_ctxt(impdef, file, lang)
IMPDEF  *impdef;
char    *file;
int     lang;
{
    SCR_strip(file);
    TXT_fd = fopen(file, "r");
    if(TXT_fd == NULL) return(-1);

//  switch(lang) {
//      case 0 : TXT_lang = 4; break; /* English */
//      case 1 : TXT_lang = 3; break; /* French */
//      case 2 : TXT_lang = 2; break; /* Dutch */
//  }
    TXT_lang = 4 - lang;

    return(0);
}

IMP_vec_ctxt(name, cmt)
char    *name;
char    **cmt;
{
    char    buf[1025], **tbl;
    int     len;

    if(fgets(buf, 1024, TXT_fd) == NULL)  return(-1);
    tbl = SCR_vtom(buf, ';');
    if(SCR_tbl_size(tbl) < 7) {
        SCR_free_tbl(tbl);
        return(-1);
    }

    SCR_strlcpy(name, tbl[0], 79);              /* JMP 13-02-2013 */
    SCR_AnsiToOem(tbl[TXT_lang], tbl[TXT_lang]);
    SCR_sqz(tbl[5]);
    SCR_sqz(tbl[6]);
    len = (int)(strlen(tbl[TXT_lang]) + strlen(tbl[5]) + strlen(tbl[6]) + 10);
    *cmt = SW_nalloc(len);

    sprintf(*cmt, "%s (%s, %s)",tbl[TXT_lang], tbl[5], tbl[6]);

    SCR_free_tbl(tbl);
    return(0);
}


IMP_end_ctxt()
{
    fclose(TXT_fd);
    TXT_fd = NULL;
    return(0);
}



IMPDEF IMP_TXT_CMT = {
    NULL,
    0,
    IMP_hd_ctxt,
    IMP_vec_ctxt,
    NULL,
    IMP_end_ctxt
};








