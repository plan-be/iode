/**
 *  @header4iode
 * 
 *  Functions to import variables and comments from the legacy Bistel format (obsolete). 
 *  
 *  When loaded in 123, the format generated by the Belgostat program is as follows:
 *  
 *  BISTEL VAR format
 *  -----------------
 *     123456789012345     1       1980      1             456900     1       1
 *     (series nb)       (freq)    (year)    (per in year) (value)  (status)  (free)
 *     ........
 *
 *  List of functions 
 *  -----------------
 *  See k_idif.c for a similar group of functions.
 */
#include <math.h>

#include "api/k_super.h"
#include "api/constants.h"
#include "api/time/period.h"
#include "api/time/sample.h"
#include "api/objs/kdb.h"
#include "api/objs/objs.h"
#include "api/io/dif.h"
#include "api/io/import.h"


int ImportObjsBST::read_header(YYFILE* yy, Sample* smpl)
{
    double  value;

    memcpy(&BST_smpl, smpl, sizeof(Sample));
    BST_freq = (BST_smpl.start_period).periodicity;
    BST_nbper = get_nb_periods_per_year(BST_smpl.start_period.periodicity);
    if(BST_nbper < 0) 
    {
        kerror(0, "Please specify FROM and TO period");
        return(-1);
    }

    if(YY_lex(yy) != DIF_TABLE) return(-1);

    if(dif_skip_to(yy, DIF_VECTORS) < 0) return(-1);
    if(dif_read_cell(yy, NULL, &value) < 0) return(-1) ;

    if(dif_skip_to(yy, DIF_TUPLES) < 0) return(-1);
    if(dif_read_cell(yy, NULL, &value) < 0)  return(-1) ;

    if(dif_skip_to(yy, DIF_BOT) < 0) return(-1);

    memcpy(&BST_smpl, smpl, sizeof(Sample));
    return(0);
}

int ImportObjsBST::read_numerical_value(YYFILE* yy, char* name, int* shift, double* vector)
{
    char    buf[21], *str = NULL;
    long    y, s, nbper;
    double  value, status;

    while(1) {
        if(dif_read_cell(yy, &str, NULL) < 0) return(-1);
        SCR_strlcpy((unsigned char*) name, (unsigned char*) str, 79); /* JMP 13-02-2013 */

        if(dif_read_cell(yy, NULL, &value) < 0) return(-1);
        nbper = (long)floor(value);
        if(nbper != BST_nbper) {
            dif_skip_to(yy, DIF_BOT);
            continue;
        }
        else break;
    }

    if(dif_read_cell(yy, NULL, &value) < 0) return(-1);
    y = (long) floor(value);
    if(dif_read_cell(yy, NULL, &value) < 0) return(-1);
    s = (long)floor(value);
    sprintf(buf, "%ld%c%ld", y, BST_freq, s);
    Period* per = new Period(std::string(buf));
    *shift = per->difference(BST_smpl.start_period);
    delete per;
    per = nullptr;

    if(dif_read_cell(yy, NULL, &value) < 0) return(-1);
    if(dif_read_cell(yy, NULL, &status) < 0) return(-1);
    if(status < 2) *vector = IODE_NAN;
    else *vector = value;

    dif_skip_to(yy, DIF_BOT);
    return(0);
}

/* Cmt */

YYFILE* ImportCommentsBST::open_file(YYKEYS* keys, int dim, char* name, char* suffix)
{
    int     size;
    char    filename[K_MAX_FILE + 1];

    YY_CASE_SENSITIVE = 1;
    if(keys != NULL) size = dim;
    else size = 0;

    sprintf(filename, "%s%s", name, suffix);
    return(YY_open(filename, keys, size, YY_FILE));
}

char* ImportCommentsBST::add_ftr(char* cmt, long rubr, int lang)
{
    char    *fc = NULL, *nc = NULL, *ft;
    long    dummy, rub;

    while(1) {
        if(DIF_long(FYY, &dummy) < 0) break;  /* tbl */
        if(DIF_long(FYY, &dummy) < 0) break;  /* dom */
        if(DIF_long(FYY, &dummy) < 0) break;  /* as */

        if(DIF_long(FYY, &rub) < 0) break;

        if(dif_read_cell(FYY, &fc, NULL) < 0) break;
        if(dif_read_cell(FYY, &nc, NULL) < 0) break;
        dif_skip_to(FYY, DIF_BOT);

        if(rubr == rub) break;
        SW_nfree(fc);
        SW_nfree(nc);
        fc = nc = NULL;
    }

    switch(lang) {
        case 0 :
            ft = NULL;
            break;
        case 1 :
            ft = fc;
            break;
        case 2 :
            ft = nc;
            break;
    }

    if(ft) {
        cmt = (char*) SW_nrealloc(cmt, (int)strlen(cmt), (int)strlen(cmt) + (int)strlen(ft) + 5); /* JMP 07-04-98 */
        sprintf(cmt + strlen(cmt), " (%s) ", ft);
    }

    SW_nfree(fc);
    SW_nfree(nc);

    return(cmt);
}

int ImportCommentsBST::sub_read_header(int lang)
{
    char    *fc = NULL, *nc = NULL, *cmt = NULL; /* JMP 04-08-98 */
    long    dummy, rub, niv, ftr;
    char    name[80];
    int     lrub;

    if(dif_skip_to(SYY, DIF_BOT) < 0) return(-1);
    if(dif_skip_to(FYY, DIF_BOT) < 0) return(-1);
    if(dif_skip_to(RYY, DIF_BOT) < 0) return(-1);

    C_kdb = new KDB(COMMENTS, DB_GLOBAL);

    while(1) {
        if(DIF_long(RYY, &dummy) < 0) break;  /* tbl */
        if(DIF_long(RYY, &dummy) < 0) break;  /* dom */
        if(DIF_long(RYY, &dummy) < 0) break;  /* as */

        if(DIF_long(RYY, &rub) < 0) break;
        if(DIF_long(RYY, &niv) < 0) break;
        if(DIF_long(RYY, &ftr)  < 0) break;

        if(dif_read_cell(RYY, &fc, NULL) < 0) break;
        if(dif_read_cell(RYY, &nc, NULL) < 0) break;
        dif_skip_to(RYY, DIF_BOT);

        lrub = (int)floor(log10((double) rub));
        switch(lrub) {
            case 0  :
                sprintf(name, "C000%ld_%ld", rub, niv);
                break;
            case 1  :
                sprintf(name, "C00%ld_%ld", rub, niv);
                break;
            case 2  :
                sprintf(name, "C0%ld_%ld", rub, niv);
                break;
            case 3  :
                sprintf(name, "C%ld_%ld", rub, niv);
                break;
            default :
                return(-1);
        }

        switch(lang) {
            case 0 :
                cmt = NULL;
                break;
            case 1 :
                cmt = (char*) SCR_stracpy((unsigned char*) fc); /* JMP 04-08-98 */
                break;
            case 2 :
                cmt = (char*) SCR_stracpy((unsigned char*) nc); /* JMP 04-08-98 */
                break;
        }

        if(ftr) cmt = add_ftr(cmt, rub, lang);

        if(cmt && !K_add(C_kdb, name, cmt)) 
            return(-1);

        SW_nfree(fc);
        SW_nfree(nc);
        SW_nfree(cmt); /* JMP 04-08-98 */
    }

    YY_close(RYY);
    return(0);
}

int ImportCommentsBST::read_header(ImportCmtFromFile* impdef, char* file, int lang)
{
    SCR_strip((unsigned char*) file);
    FYY = open_file(impdef->imp_keys, impdef->imp_dim, file, "ftr.dif");
    RYY = open_file(impdef->imp_keys, impdef->imp_dim, file, "rub.dif");
    SYY = open_file(impdef->imp_keys, impdef->imp_dim, file, "ser.dif");

    if(FYY == 0 || RYY == 0 || SYY == 0) {
        kerror(0,"Cannot open '%s'", file);
        return(-1);
    }

    if(sub_read_header(lang) < 0) {
        close();
        return(-1);
    }

    return(0);
}

int ImportCommentsBST::DIF_long(YYFILE* yy, long* l_val)
{
    double  d_val;

    if(dif_read_cell(yy, NULL, &d_val) < 0) return(-1);

    *l_val = (long)floor(d_val);
    return(0);
}

int ImportCommentsBST::read_comment(char* name, char** cmt)
{
    char    *str = NULL, *p_cmt[10];
    int     i, niv, r_niv, shift;
    long    dom, tbl, as1, as2;

    for(i = 0; i < 10; i++)
        p_cmt[i] = NULL;

    name[0] = '0';
    while(name[0] == '0') 
    {
        if(DIF_long(SYY, &dom) < 0) return(-1);
        if(DIF_long(SYY, &tbl) < 0) return(-1);
        if(DIF_long(SYY, &as1) < 0) return(-1);
        if(DIF_long(SYY, &as2) < 0) return(-1);

        if(dif_read_cell(SYY, &str, NULL) < 0) return(-1);
        strcpy(name, str);
        SW_nfree(str);
        dif_skip_to(SYY, DIF_BOT);
    }
    as1 --;

    char* name1 = (char*) C_kdb->get_name(as1).c_str();
    niv = get_niv(name1);
    if(niv < 1 || niv > 9) 
        return(-1);

    shift = niv;
    while(niv > 0 && as1 >= 0) 
    {
        r_niv = get_niv(name1);
        if(niv == r_niv) 
        {
            str = K_optr0(C_kdb, name);
            SCR_strfacpy((unsigned char**) p_cmt + niv - 1, (unsigned char*) str);

            niv --;
        }
        as1 --;
    }

    if(as2 > 0) 
    {
        char* name2 = (char*) C_kdb->get_name(as2).c_str();
        niv = get_niv(name2);
        while(niv > 0 && as2 >= 0 && niv + shift < 10) 
        {
            r_niv = get_niv(name2);
            if(niv == r_niv) 
            {
                str = K_optr0(C_kdb, name2);
                SCR_strfacpy((unsigned char**) p_cmt + niv + shift - 1, (unsigned char*) str);
                niv --;
            }
            as2 --;
        }
    }

    *cmt = (char*) SCR_mtov((unsigned char**) p_cmt, (int) ' ');

    for(i = 0; i < 10 && p_cmt[i]; i++) 
    {
        SCR_free(p_cmt[i]);
        p_cmt[i] = NULL;
    }

    return(0);
}

int ImportCommentsBST::get_niv(char* name)
{
    int     pos, niv;
    ONAME   oname;
    char    *str;

    strcpy(oname, name);
    pos = U_pos('_', (unsigned char*) oname);
    str = oname + pos + 1;
    niv = atoi(str);

    return(niv);
}

int ImportCommentsBST::close()
{
    delete C_kdb;
    YY_close(SYY);
    YY_close(FYY);
    return(0);
}
