<!-- This content was generated by scr4w_amd -->

# Table of Contents



- [IODE: LEC implementation](#T1)
    - [Summary](#T2)
      - [Step 1: LEC interpreter](#T3)
      - [Step 2: LEC serializing](#T4)
      - [Step 3. LEC linker](#T5)
      - [Step 4: LEC calculator](#T6)
    - [Example of a LEC expression compilation](#T7)
  - [LEC syntax](#T8)
    - [l\_token.c](#T9)
  - [LEC utilities](#T10)
    - [l\_alloc.c](#T11)
    - [l\_err.c](#T12)
  - [LEC compiler](#T13)
    - [l\_token.c](#T14)
    - [l\_cc1.c](#T15)
    - [l\_cc2.c](#T16)
    - [l\_eqs.c](#T17)
  - [LEC linker](#T18)
    - [l\_link.c](#T19)
  - [LEC execution](#T20)
    - [l\_exec.c](#T21)
    - [l\_exec\_var.c](#T22)
    - [l\_exec\_ops.c](#T23)
    - [l\_exec\_fns.c](#T24)
    - [l\_exec\_tfn.c](#T25)
    - [l\_exec\_mtfn.c](#T26)
  - [LEC virtual functions](#T27)
    - [k\_lec.c](#T28)

# IODE: LEC implementation {#T1}

### Summary {#T2}

A LEC expression is compiled, linked and evaluated in 4 steps.

#### Step 1: LEC interpreter {#T3}

During the first step (l\_cc1.c), 2 tables, L\_EXPR with atomic expressions and L\_NAMES with the names found in the LEC expression are constructed. L\_EXPR is organised in "stack\-oriented" order. That step makes use of l\_token.c functions.

#### Step 2: LEC serializing {#T4}

In a second step (l\_cc2.c), a "CLEC expression" is generated which is basically the serialization of the combination of L\_EXPR and L\_NAMES.

#### Step 3. LEC linker {#T5}

The CLEC expression can then be linked to the KDB's of variables and scalars (l\_link.c). Each name is searched in the KDB's and their respective positions is saved in the CLEC structure.

#### Step 4: LEC calculator {#T6}

Finally, the expression is computed by the fonction L\_exec (l\_exec.c).

### Example of a LEC expression compilation {#T7}

Let's compile the following expression:

```
    A + ln(B)
```

At the end of the first compilation step, two tables are created:

L\_NAMES which is a table with the names found in the LEC expression:

|Names|
|:---|
|A|
|B|

and L\_EXPR that can be sketched as:

|Type|Value|
|:---|:---|
|L\_VAR|0 (= pos of A in L\_NAMES)|
|L\_OPENP||
|L\_VAR|1 (= pos of B in L\_NAMES)|
|L\_CLOSEP||
|L\_LN||
|L\_PLUS||

During the second step (l\_cc2.c), a "CLEC expression" is generated which is the serialization of the combination of L\_EXPR and L\_NAMES.

A simplified version of the resulting "executable" expression (kind of "Reverted Polish Notation") is:

|Size|Type|Value|
|:---|:---|:---|
|21|L\_VAR|CVAR: \{0, 0, 0, \{0,0,0\}\} = \{pos of A in L\_NAMES, lag, ref, period\}|
|21|L\_VAR|CVAR: \{1, 0, 0, \{0,0,0\}\} = \{pos of B in L\_NAMES, lag, ref, period\}|
|2|L\_LN|1 (nb of arguments)|
|1|L\_PLUS||

Finally, the CLEC \*struct\* regroups the following data:

- total length of the CLEC struct
- length of executable expression
- nb of names
- dupendo (reserved for equations)
- table of LNAME's
- executable expression described above

**Groups of functions and variables**

- LEC syntax: variables defining the LEC syntax
- LEC utilities: LEC memory allocation \+ LEC error management
- LEC compiler: to check the syntax of a LEC expression and to produce a precompiled structure (CLEC)
- LEC linker: to link the CLEC structure to the variables and scalars in KDB's
- LEC execution: to calculate the value of a CLEC expression in the context of specific KDB's
- LEC virtual functions: functions that can be rewritten for use in other contexts than KDB databases

## LEC syntax {#T8}

The LEC syntax depends on variables defined in l\_token.c. These variables are also related to \#define's in iode.h.

### l\_token.c {#T9}

|Variable|Description|
|:---|:---|
|`L_TABLE `|keywords recognised in a LEC expression, like '\+' or 'ln'|
|`L_PRIOR `|table of the operator execution priorities (which one is executed first, second...)|
|`L_MIN_FARGS `|table of minimum number of arguments for the math functions (like log())|
|`L_MAX_FARGS `|table of maximum number of arguments for the math functions|
|`L_MIN_TARGS `|table of minimum number of arguments for the time functions (like grt())|
|`L_MAX_TARGS `|table of minimum number of arguments for the time functions|
|`L_MIN_MTARGS `|table of minimum number of arguments for the functions with multiple time expressions|
|`L_MAX_MTARGS `|table of minimum number of arguments for the functions with multiple time expressions|

These variables may be changed (but with some care).

## LEC utilities {#T10}

### l\_alloc.c {#T11}

Functions to allocate and free standard memory (on the "heap") for the LEC group of functions. Could be replaced by another implementation if needed.

|Syntax|Description|
|:---|:---|
|char \*L\_malloc(int lg)|Allocates lg bytes in conventional memory. Fills the allocated space with nulls.|
|void L\_free(void \*ptr)|Frees an allocated buffer. If ptr is null, does nothing.|

### l\_err.c {#T12}

Function and variables to manage error messages.

|Syntax|Description|
|:---|:---|
|int L\_errno|Last error number during LEC compilation|
|char\* L\_error()|Returns a static buffer containing the last LEC compilation error message.|

## LEC compiler {#T13}

### l\_token.c {#T14}

Functions and associated variables to "open" a LEC expression and to read the expression one token at a time.

The variables defining the LEC syntax (L\_TABLE, L\_PRIOR, L\_MIN...) are described above.

Main functions:

|Syntax|Description|
|:---|:---|
|int L\_open\_all(char\* file\_or\_string, int type)|Opens a file or a string for reading and assigns the open stream to L\_YY.|
|void L\_close()|Close the stream L\_YY.|
|int L\_get\_token()|Main function to browse a LEC expression (in L\_YY) token by token.|

### l\_cc1.c {#T15}

First step of LEC compilation.

Main functions:

|Syntax|Description|
|:---|:---|
|int L\_cc1(int nb\_names)|Creates L\_EXPR(ordered list of atomic expressions with references to L\_NAMES) and L\_NAMES (list of names in the LEC expression)|
|void L\_alloc\_expr(int nb)|Allocates or reallocates L\_EXPR by blocks of 100 elements.|
|int L\_sub\_expr(ALEC\* al, int i)|Computes the position of the beginning of a sub\-expression|

### l\_cc2.c {#T16}

Second step of LEC compilation, producing a "CLEC expression" which contains what is needed to efficiently evaluate the expression.

Main functions:

|Syntax|Description|
|:---|:---|
|CLEC \*L\_cc2(ALEC\* expr)|Second stage of LEC compilation. Generates an "executable" LEC expression.|
|void L\_move\_arg(char \*s1, char \*s2, int lg)|Copies lg bytes from a buffer to another in reverse order. The 2 buffers may overlap.|
|CLEC \*L\_cc\_stream()|Compiles L\_YY, the open YY stream containing a LEC expression.|
|CLEC \*L\_cc(char\* lec)|Compiles a LEC string.|

### l\_eqs.c {#T17}

Functions to compile LEC \*equations\*. LEC \*equations\* are made up of 2 LEC \*expressions\* separated by ":=". Equations are used in 2 different contexts: estimation of coefficients and model simulation.

Main functions:

|Syntax|Description|
|:---|:---|
|CLEC\* L\_solve(char\* eq, char\* endo)|Compiles a LEC equation and tries to analytically solve the equation with respect to endo.|
|int L\_split\_eq(char\* eq)|Returns the position of ":=" in an equation or \-1 if not found.|

More details and examples can be found in the source file.

## LEC linker {#T18}

The third step consists in linking the CLEC expression to the KDB of variables and scalars. Each name is searched in the KDB's and their position is placed in l\_names\[i\].pos.

Three functions, implemented in k\_lec.c, are called during the link process: L\_findvar(), L\_findscl() L\_getsmpl(). The positions of variables and scalars returned by these functions will be used at execution time by L\_getvar() and L\_getscl().

### l\_link.c {#T19}

|Syntax|Description|
|:---|:---|
|   int L\_link(KDB\* dbv, KDB\* dbs, CLEC\* cl)|Links a CLEC expression to KDB's of variables and scalars. Aligns PERIOD's to the SAMPLE of dbv.|
|   void L\_link\_endos(KDB \*dbe, CLEC \*cl)|Pseudo linking used to calculate the strong connex components of a model (SCC).|

## LEC execution {#T20}

Finally, the expression is calculated by the fonction L\_exec().

### l\_exec.c {#T21}

Functions to evaluate a compiled and linked LEC expression.

|Syntax|Description|
|:---|:---|
|L\_REAL L\_exec\_sub(unsigned char\* expr, int lg, int t, L\_REAL\* stack)|Execution of a CLEC sub expression.|
|L\_REAL L\_exec(KDB\* dbv, KDB\* dbs, CLEC\* expr, int t)|Execution of a compiled and linked CLEC expression.|

### l\_exec\_var.c {#T22}

Functions to evaluate LEC "values":

|Syntax|Description|
|:---|:---|
|static L\_REAL L\_pi ()||
|static L\_REAL L\_euro()||
|static L\_REAL L\_e ()||
|static L\_REAL L\_time(int t)||
|static L\_REAL L\_i(int t)||

### l\_exec\_ops.c {#T23}

Functions to evaluate LEC "operators".

|Syntax|Description|
|:---|:---|
|static L\_REAL L\_or (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_and (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_ge (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_gt (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_le (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_lt (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_eq (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_ne (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_plus (L\_REAL a, L\_REAL b)||
|static L\_REAL L\_minus(L\_REAL a, L\_REAL b)||
|static L\_REAL L\_times(L\_REAL a, L\_REAL b)||
|       L\_REAL L\_divide(L\_REAL a, L\_REAL b)||
|       L\_REAL L\_exp(L\_REAL a, L\_REAL b)||

### l\_exec\_fns.c {#T24}

Functions to evaluate LEC "functions".

|Syntax|Description|
|:---|:---|
|L\_REAL L\_logn(L\_REAL v)||
|static L\_REAL L\_uminus(L\_REAL\* stack)||
|static L\_REAL L\_uplus (L\_REAL\* stack)||
|static L\_REAL L\_log(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_ln(L\_REAL\* stack)||
|static L\_REAL L\_not(L\_REAL\* stack)||
|static L\_REAL L\_expn(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_max(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_min(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_sin (L\_REAL\* stack)||
|static L\_REAL L\_cos (L\_REAL\* stack)||
|static L\_REAL L\_acos (L\_REAL\* stack)||
|static L\_REAL L\_asin (L\_REAL\* stack)||
|static L\_REAL L\_tan (L\_REAL\* stack)||
|static L\_REAL L\_atan (L\_REAL\* stack)||
|static L\_REAL L\_tanh (L\_REAL\* stack)||
|static L\_REAL L\_sinh (L\_REAL\* stack)||
|static L\_REAL L\_cosh (L\_REAL\* stack)||
|static L\_REAL L\_abs (L\_REAL\* stack)||
|static L\_REAL L\_sqrt (L\_REAL\* stack)||
|static L\_REAL L\_int (L\_REAL\* stack)||
|static L\_REAL L\_rad (L\_REAL\* stack)||
|static L\_REAL L\_if(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_lsum(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_lmean(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_fnisan(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_lcount(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_lprod(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_sign(L\_REAL\* stack)||
|static L\_REAL L\_lstderr(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_random(L\_REAL\* stack)||
|static L\_REAL L\_floor(L\_REAL\* stack)||
|static L\_REAL L\_ceil (L\_REAL\* stack)||
|static L\_REAL L\_round(L\_REAL\* stack, int nargs)||
|static L\_REAL L\_urandom(L\_REAL\* stack)||
|static L\_REAL L\_grandom(L\_REAL\* stack)||
|static L\_REAL L\_gamma(L\_REAL\* stack)||
|static L\_REAL L\_div0(L\_REAL \*stack, int nargs)||

### l\_exec\_tfn.c {#T25}

Functions to evaluate LEC "time functions".

|Syntax|Description|
|:---|:---|
|static L\_REAL L\_lag(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_diff(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_rapp(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_dln(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_grt(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_mavg(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_vmax(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_vmin(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_sum(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_prod(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|       L\_REAL L\_mean(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_stderr(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_lastobs(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||

### l\_exec\_mtfn.c {#T26}

Functions to evaluate LEC "time functions" with possibly multiple arguments.

|Syntax|Description|
|:---|:---|
|static L\_REAL L\_calccorr(unsigned char\* expr1, short len1, unsigned char\* expr2, short len2, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_corr(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_calccovar(unsigned char\* expr1, short len1, unsigned char\* expr2, short len2, int t, L\_REAL\* stack, int nargs, int orig)||
|static L\_REAL L\_covar(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_covar0(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_var(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_stddev(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_index(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_acf(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static int L\_calcvals(unsigned char\* expr1, short len1, int t, L\_REAL\* stack, int\* vt, L\_REAL\* vy, int notnul)||
|static L\_REAL L\_interpol(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_app(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_dapp(unsigned char\* expr, short nvargs, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_hpall(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs, int std)||
|static L\_REAL L\_hp(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||
|static L\_REAL L\_hpstd(unsigned char\* expr, short len, int t, L\_REAL\* stack, int nargs)||

## LEC virtual functions {#T27}

### k\_lec.c {#T28}

Implemention of the LEC library virtual functions for SCL and VAR references.

|Syntax|Description|
|:---|:---|
|IODE\_REAL \*L\_getvar(KDB\* kdb, int pos)||
|IODE\_REAL L\_getscl(KDB\* kdb, int pos)||
|SAMPLE \*L\_getsmpl(KDB\* kdb)||
|int L\_findscl(KDB\* kdb, char \*name)||
|int L\_findvar(KDB\* kdb, char\* name)||

