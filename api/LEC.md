<!-- This content was generated by scr4w_amd -->

# Table of Contents



- [IODE: LEC implementation](#T1)
    - [Summary](#T2)
      - [Step 1: LEC interpreter](#T3)
      - [Step 2: LEC serializing](#T4)
      - [Step 3. LEC linker](#T5)
      - [Step 4: LEC calculator](#T6)
    - [Example of a LEC expression compilation](#T7)
  - [LEC syntax](#T8)
    - [l\_token.c](#T9)
  - [LEC utilities](#T10)
    - [l\_alloc.c](#T11)
    - [l\_err.c](#T12)
    - [l\_debug.c](#T13)
  - [LEC compiler](#T14)
    - [l\_token.c](#T15)
    - [l\_cc1.c](#T16)
    - [l\_cc2.c](#T17)
    - [l\_eqs.c](#T18)
  - [LEC linker](#T19)
    - [l\_link.c](#T20)
  - [LEC execution](#T21)
    - [l\_exec.c](#T22)
    - [l\_exec\_var.c](#T23)
    - [l\_exec\_ops.c](#T24)
    - [l\_exec\_fns.c](#T25)
    - [l\_exec\_tfn.c](#T26)
    - [l\_exec\_mtfn.c](#T27)
    - [l\_hodrick.c](#T28)
  - [LEC virtual functions](#T29)
    - [k\_lec.c](#T30)

# IODE: LEC implementation {#T1}

### Summary {#T2}

A LEC expression is compiled, linked and evaluated in 4 steps.

#### Step 1: LEC interpreter {#T3}

During the first step (l\_cc1.c), 2 tables, L\_EXPR with atomic expressions and L\_NAMES with the names found in the LEC expression are constructed. L\_EXPR is organised in "stack\-oriented" order. That step makes use of l\_token.c functions.

#### Step 2: LEC serializing {#T4}

In a second step (l\_cc2.c), a "CLEC expression" is generated which is basically the serialization of the combination of L\_EXPR and L\_NAMES.

#### Step 3. LEC linker {#T5}

The CLEC expression can then be linked to the KDB's of variables and scalars (l\_link.c). Each name is searched in the KDB's and their respective positions is saved in the CLEC structure.

#### Step 4: LEC calculator {#T6}

Finally, the expression is computed by the fonction L\_exec (l\_exec.c).

### Example of a LEC expression compilation {#T7}

Let's compile the following expression:

```
    A + ln(B)
```

At the end of the first compilation step, two tables are created:

L\_NAMES which is a table with the names found in the LEC expression:

|Names|
|:---|
|A|
|B|

and L\_EXPR that can be sketched as:

|Type|Value|
|:---|:---|
|L\_VAR|0 (= pos of A in L\_NAMES)|
|L\_OPENP||
|L\_VAR|1 (= pos of B in L\_NAMES)|
|L\_CLOSEP||
|L\_LN||
|L\_PLUS||

During the second step (l\_cc2.c), a "CLEC expression" is generated which is the serialization of the combination of L\_EXPR and L\_NAMES.

A simplified version of the resulting "executable" expression (kind of "Reverted Polish Notation") is:

|Size|Type|Value|
|:---|:---|:---|
|21|L\_VAR|CVAR: \{0, 0, 0, \{0,0,0\}\} = \{pos of A in L\_NAMES, lag, ref, period\}|
|21|L\_VAR|CVAR: \{1, 0, 0, \{0,0,0\}\} = \{pos of B in L\_NAMES, lag, ref, period\}|
|2|L\_LN|1 (nb of arguments)|
|1|L\_PLUS||

Finally, the CLEC \*struct\* regroups the following data:

- total length of the CLEC struct
- length of executable expression
- nb of names
- dupendo (reserved for equations)
- table of LNAME's
- executable expression described above

**Groups of functions and variables**

- LEC syntax: variables defining the LEC syntax
- LEC utilities: LEC memory allocation \+ LEC error management
- LEC compiler: to check the syntax of a LEC expression and to produce a precompiled structure (CLEC)
- LEC linker: to link the CLEC structure to the variables and scalars in KDB's
- LEC execution: to calculate the value of a CLEC expression in the context of specific KDB's
- LEC virtual functions: functions that can be rewritten for use in other contexts than KDB databases

## LEC syntax {#T8}

The LEC syntax depends on variables defined in l\_token.c. These variables are also related to \#define's in iode.h.

### l\_token.c {#T9}

|Variable|Description|
|:---|:---|
|`L_TABLE `|keywords recognised in a LEC expression, like '\+' or 'ln'|
|`L_PRIOR `|table of the operator execution priorities (which one is executed first, second...)|
|`L_MIN_FARGS `|table of minimum number of arguments for the math functions (like log())|
|`L_MAX_FARGS `|table of maximum number of arguments for the math functions|
|`L_MIN_TARGS `|table of minimum number of arguments for the time functions (like grt())|
|`L_MAX_TARGS `|table of minimum number of arguments for the time functions|
|`L_MIN_MTARGS `|table of minimum number of arguments for the functions with multiple time expressions|
|`L_MAX_MTARGS `|table of minimum number of arguments for the functions with multiple time expressions|

These variables may be changed (but with some care).

## LEC utilities {#T10}

### l\_alloc.c {#T11}

Functions to allocate and free standard memory (on the "heap") for the LEC group of functions. Could be replaced by another implementation if needed.

|Syntax|Description|
|:---|:---|
|`char *L_malloc(int lg)`|Allocates lg bytes in conventional memory. Fills the allocated space with nulls.|
|`void L_free(void *ptr)`|Frees an allocated buffer. If ptr is null, does nothing.|

### l\_err.c {#T12}

Function and variables to manage error messages.

|Syntax|Description|
|:---|:---|
|`int L_errno`|Last error number during LEC compilation|
|`char* L_error()`|Returns a static buffer containing the last LEC compilation error message.|

### l\_debug.c {#T13}

Function to save debugging info in a text file.

|Syntax|Description|
|:---|:---|
|`void L_debug(char* fmt, ...)`|appends a message to the file L\_DEBUG\_FILENAME ("simul.dbg" by default).|
|**bGlobal variable**||
|`char* L_DEBUG_FILENAME = 0;`|name of the output file (default "simul.dbg")|

## LEC compiler {#T14}

### l\_token.c {#T15}

Functions and associated variables to "open" a LEC expression and to read the expression one token at a time.

The variables defining the LEC syntax (L\_TABLE, L\_PRIOR, L\_MIN...) are described above.

Main functions:

|Syntax|Description|
|:---|:---|
|`int L_open_all(char* file_or_string, int type)`|Opens a file or a string for reading and assigns the open stream to L\_YY.|
|`void L_close()`|Close the stream L\_YY.|
|`int L_get_token()`|Main function to browse a LEC expression (in L\_YY) token by token.|

### l\_cc1.c {#T16}

First step of LEC compilation.

Main functions:

|Syntax|Description|
|:---|:---|
|`int L_cc1(int nb_names)`|Creates L\_EXPR(ordered list of atomic expressions with references to L\_NAMES) and L\_NAMES (list of names in the LEC expression)|
|`void L_alloc_expr(int nb)`|Allocates or reallocates L\_EXPR by blocks of 100 elements.|
|`int L_sub_expr(ALEC* al, int i)`|Computes the position of the beginning of a sub\-expression|

### l\_cc2.c {#T17}

Second step of LEC compilation, producing a "CLEC expression" which contains what is needed to efficiently evaluate the expression.

Main functions:

|Syntax|Description|
|:---|:---|
|`CLEC *L_cc2(ALEC* expr)`|Second stage of LEC compilation. Generates an "executable" LEC expression.|
|`void L_move_arg(char *s1, char *s2, int lg)`|Copies lg bytes from a buffer to another in reverse order. The 2 buffers may overlap.|
|`CLEC *L_cc_stream()`|Compiles L\_YY, the open YY stream containing a LEC expression.|
|`CLEC *L_cc(char* lec)`|Compiles a LEC string.|

### l\_eqs.c {#T18}

Functions to compile LEC \*equations\*. LEC \*equations\* are made up of 2 LEC \*expressions\* separated by ":=". Equations are used in 2 different contexts: estimation of coefficients and model simulation.

Main functions:

|Syntax|Description|
|:---|:---|
|`CLEC* L_solve(char* eq, char* endo)`|Compiles a LEC equation and tries to analytically solve the equation with respect to endo.|
|`int L_split_eq(char* eq)`|Returns the position of ":=" in an equation or \-1 if not found.|

More details and examples can be found in the source file.

## LEC linker {#T19}

The third step consists in linking the CLEC expression to the KDB of variables and scalars. Each name is searched in the KDB's and their position is placed in l\_names\[i\].pos.

Three functions, implemented in k\_lec.c, are called during the link process: L\_findvar(), L\_findscl() L\_getsmpl(). The positions of variables and scalars returned by these functions will be used at execution time by L\_getvar() and L\_getscl().

### l\_link.c {#T20}

|Syntax|Description|
|:---|:---|
|`int L_link(KDB* dbv, KDB* dbs, CLEC* cl)`|Links a CLEC expression to KDB's of variables and scalars. Aligns PERIOD's to the SAMPLE of dbv.|
|`void L_link_endos(KDB *dbe, CLEC *cl)`|Pseudo linking used to calculate the strong connex components of a model (SCC).|

## LEC execution {#T21}

Finally, the expression is calculated by the fonction L\_exec().

### l\_exec.c {#T22}

Functions to evaluate a compiled and linked LEC expression.

|Syntax|Description|
|:---|:---|
|`L_REAL L_exec_sub(unsigned char* expr, int lg, int t, L_REAL* stack)`|Execution of a CLEC sub expression.|
|`L_REAL L_exec(KDB* dbv, KDB* dbs, CLEC* expr, int t)`|Execution of a compiled and linked CLEC expression.|

### l\_exec\_var.c {#T23}

Functions to evaluate LEC constants:

|Syntax|Description|
|:---|:---|
|`static L_REAL L_pi ()`||
|`static L_REAL L_euro()`||
|`static L_REAL L_e ()`||
|`static L_REAL L_time(int t)`||
|`static L_REAL L_i(int t)`||

### l\_exec\_ops.c {#T24}

Functions to evaluate LEC "operators".

|Syntax|Description|
|:---|:---|
|`static L_REAL L_or (L_REAL a, L_REAL b)`||
|`static L_REAL L_and (L_REAL a, L_REAL b)`||
|`static L_REAL L_ge (L_REAL a, L_REAL b)`||
|`static L_REAL L_gt (L_REAL a, L_REAL b)`||
|`static L_REAL L_le (L_REAL a, L_REAL b)`||
|`static L_REAL L_lt (L_REAL a, L_REAL b)`||
|`static L_REAL L_eq (L_REAL a, L_REAL b)`||
|`static L_REAL L_ne (L_REAL a, L_REAL b)`||
|`static L_REAL L_plus (L_REAL a, L_REAL b)`||
|`static L_REAL L_minus(L_REAL a, L_REAL b)`||
|`static L_REAL L_times(L_REAL a, L_REAL b)`||
|` L_REAL L_divide(L_REAL a, L_REAL b)`||
|` L_REAL L_exp(L_REAL a, L_REAL b)`||

### l\_exec\_fns.c {#T25}

Functions to evaluate LEC "functions".

|Syntax|Description|
|:---|:---|
|`L_REAL L_logn(L_REAL v)`||
|`static L_REAL L_uminus(L_REAL* stack)`||
|`static L_REAL L_uplus (L_REAL* stack)`||
|`static L_REAL L_log(L_REAL* stack, int nargs)`||
|`static L_REAL L_ln(L_REAL* stack)`||
|`static L_REAL L_not(L_REAL* stack)`||
|`static L_REAL L_expn(L_REAL* stack, int nargs)`||
|`static L_REAL L_max(L_REAL* stack, int nargs)`||
|`static L_REAL L_min(L_REAL* stack, int nargs)`||
|`static L_REAL L_sin (L_REAL* stack)`||
|`static L_REAL L_cos (L_REAL* stack)`||
|`static L_REAL L_acos (L_REAL* stack)`||
|`static L_REAL L_asin (L_REAL* stack)`||
|`static L_REAL L_tan (L_REAL* stack)`||
|`static L_REAL L_atan (L_REAL* stack)`||
|`static L_REAL L_tanh (L_REAL* stack)`||
|`static L_REAL L_sinh (L_REAL* stack)`||
|`static L_REAL L_cosh (L_REAL* stack)`||
|`static L_REAL L_abs (L_REAL* stack)`||
|`static L_REAL L_sqrt (L_REAL* stack)`||
|`static L_REAL L_int (L_REAL* stack)`||
|`static L_REAL L_rad (L_REAL* stack)`||
|`static L_REAL L_if(L_REAL* stack, int nargs)`||
|`static L_REAL L_lsum(L_REAL* stack, int nargs)`||
|`static L_REAL L_lmean(L_REAL* stack, int nargs)`||
|`static L_REAL L_fnisan(L_REAL* stack, int nargs)`||
|`static L_REAL L_lcount(L_REAL* stack, int nargs)`||
|`static L_REAL L_lprod(L_REAL* stack, int nargs)`||
|`static L_REAL L_sign(L_REAL* stack)`||
|`static L_REAL L_lstderr(L_REAL* stack, int nargs)`||
|`static L_REAL L_random(L_REAL* stack)`||
|`static L_REAL L_floor(L_REAL* stack)`||
|`static L_REAL L_ceil (L_REAL* stack)`||
|`static L_REAL L_round(L_REAL* stack, int nargs)`||
|`static L_REAL L_urandom(L_REAL* stack)`||
|`static L_REAL L_grandom(L_REAL* stack)`||
|`static L_REAL L_gamma(L_REAL* stack)`||
|`static L_REAL L_div0(L_REAL *stack, int nargs)`||

### l\_exec\_tfn.c {#T26}

Functions to evaluate LEC "time functions".

|Syntax|Description|
|:---|:---|
|`static L_REAL L_lag(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_diff(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_rapp(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_dln(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_grt(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_mavg(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_vmax(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_vmin(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_sum(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_prod(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|` L_REAL L_mean(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_stderr(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_lastobs(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||

### l\_exec\_mtfn.c {#T27}

Functions to evaluate LEC "time functions" with possibly multiple arguments.

|Syntax|Description|
|:---|:---|
|`static L_REAL L_calccorr(unsigned char* expr1, short len1, unsigned char* expr2, short len2, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_corr(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_calccovar(unsigned char* expr1, short len1, unsigned char* expr2, short len2, int t, L_REAL* stack, int nargs, int orig)`||
|`static L_REAL L_covar(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_covar0(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_var(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_stddev(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_index(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_acf(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static int L_calcvals(unsigned char* expr1, short len1, int t, L_REAL* stack, int* vt, L_REAL* vy, int notnul)`||
|`static L_REAL L_interpol(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_app(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_dapp(unsigned char* expr, short nvargs, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_hpall(unsigned char* expr, short len, int t, L_REAL* stack, int nargs, int std)`||
|`static L_REAL L_hp(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||
|`static L_REAL L_hpstd(unsigned char* expr, short len, int t, L_REAL* stack, int nargs)`||

### l\_hodrick.c {#T28}

Hodrick\-Prescott filter. These functions are subfunctions of L\_hp\*() defined on l\_exec\_mtfn.c.

|Syntax|Description|
|:---|:---|
|`int HP_calc(IODE_REAL *f_vec, IODE_REAL *t_vec, int nb, IODE_REAL lambda, int std)`|Hodrick\-Prescott filter.|
|`void HP_test(IODE_REAL *f_vec, IODE_REAL *t_vec, int nb, int *beg, int *dim)`|Prepares HP\_calc()|

## LEC virtual functions {#T29}

### k\_lec.c {#T30}

Implemention of the LEC library virtual functions for SCL and VAR references.

|Syntax|Description|
|:---|:---|
|`IODE_REAL *L_getvar(KDB* kdb, int pos)`|Retrieves a pointer to the first element of a VAR.|
|`IODE_REAL L_getscl(KDB* kdb, int pos)`|Retrieves a scalar value.|
|`SAMPLE *L_getsmpl(KDB* kdb)`|Retrieves the sample of a KDB.|
|`int L_findscl(KDB* kdb, char *name)`|Retrieves a scalar position.|
|`int L_findvar(KDB* kdb, char* name)`|Retrieves a variable position.|

