<!-- This content was generated by scr4w_amd -->

# Table of Contents



- [IODE: Model Simulation](#T1)
    - [k\_sim\_main.c](#T2)
    - [k\_sim\_order.c](#T3)
    - [k\_sim\_scc.c](#T4)
    - [k\_sim\_exo2endo.c](#T5)
    - [Single equation solver](#T6)
      - [l\_newton.c](#T7)
      - [l\_secant.c](#T8)

# IODE: Model Simulation {#T1}

### k\_sim\_main.c {#T2}

Main functions for model simulations.

|Syntax|Description|
|:---|:---|
|`int K_simul(KDB* dbe, KDB* dbv, KDB* dbs, SAMPLE* smpl, char** endo_exo, char** eqs)`|Simulates a model defined by a set of equations and optional replacements endo\-exo.|
|`void K_simul_free()`|Frees all temporary allocated memory for the simulation.|
|`IODE_REAL K_calc_clec(int eqnb, int t, int varnb, int msg)`|Tries to find a value for varnb\[t\] that satifies the equality in the equation eqnb.|

### k\_sim\_order.c {#T3}

Functions to reorder a model to optimize the Gauss\-Seidel simulation algorithm.

|Syntax|Description|
|:---|:---|
|`int KE_order(KDB* dbe, char** eqs)`|Reorders a model before the simulation to optimise the execution order of the set of equations.|
|`int KE_poseq(int posendo)`|Searches the equation whose endogenous is the variable posendo.|
|`void KE_tri(KDB* dbe, int** tmp, int passes)`|Sort the equations by making successive 'pseudo\-triangulation' passes.|

### k\_sim\_scc.c {#T4}

Alternative functions to reorder and simulate very large models.

The reordering algorithm being CPU intensive for very large models, it is better to first reorder the model and save that order in such a way as to be able to run several simulations with the same order later on.

|Syntax|Description|
|:---|:---|
|`int KE_ModelCalcSCC(KDB* dbe, int tris, char* pre, char* inter, char* post)`|Reorders the model defined by dbe and saves 3 lists with prolog, epilog and interdependent blocks.|
|`int K_simul_SCC(KDB* dbe, KDB* dbv, KDB* dbs, SAMPLE* smpl, char** pre, char** inter, char** post)`|Simulates a model in the order given by 3 lists of tables of equation names: pre, inter and post.|

### k\_sim\_exo2endo.c {#T5}

It is possible to exchange the status of an exogenous variable with that of an endogenous variable. This allows, when the value of an endogenous variable is known in advance, for example during the first simulation period, to block this endogenous variable by letting an exogenous variable vary so that the known value of the endogenous variable is preserved.

Another way to view the process is to say that the model is solved with respect to another list of variables.

|Syntax|Description|
|:---|:---|
|`int KE_exo2endo(int posendo, int posexo)`|Modify the model to solve it with respect to another set of variables|

### Single equation solver {#T6}

When an equation is not analytically solved during the compilation process or if it has been inverted by the endo\-exo exchange, that equation pust be solved numerically during the simulation.

Two methods are used: a simple Newton\-Raphson method or a secant method in case of non convergence.

#### l\_newton.c {#T7}

|Syntax|Description|
|:---|:---|
|`double L_zero(KDB* dbv, KDB* dbs, CLEC* clec, int t, int varnb, int eqvarnb)`|Solves numerically a LEC equation for one period of time with respect to a given variable. If the Newton\-Raphson method does not reach a solution, tries a bisection (secant) method.|
|`double L_newton(KDB* dbv, KDB* dbs, CLEC* clec, int t, int varnb, int eqvarnb)`|Tries to solve a LEC equation by the Newton\-Raphson method.|

#### l\_secant.c {#T8}

|Syntax|Description|
|:---|:---|
|`static double L_fx(double x, int t)`|Computes the value of f(x) in time t|
|`double L_secant(KDB* dbv, KDB* dbs, CLEC* clec, int t, int varnb, int eqvarnb)`|Tries to find a solution to the equation clec by a secant method.|

